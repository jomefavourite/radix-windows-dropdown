{"ast":null,"code":"import _objectSpread from \"/project/radix-windows-dropdown/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/project/radix-windows-dropdown/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"children\"],\n    _excluded2 = [\"children\"];\nimport { composeRefs as e } from \"@radix-ui/react-compose-refs\";\nimport * as t from \"react\";\nimport r from \"@babel/runtime/helpers/esm/extends\";\nexport var Slot = /*#__PURE__*/t.forwardRef(function (e, o) {\n  var a = e.children,\n      s = _objectWithoutProperties(e, _excluded),\n      c = t.Children.toArray(a);\n\n  return c.some(l) ? /*#__PURE__*/t.createElement(t.Fragment, null, c.map(function (e) {\n    return l(e) ? /*#__PURE__*/t.createElement(n, r({}, s, {\n      ref: o\n    }), e.props.children) : e;\n  })) : /*#__PURE__*/t.createElement(n, r({}, s, {\n    ref: o\n  }), a);\n});\nSlot.displayName = \"Slot\";\nvar n = /*#__PURE__*/t.forwardRef(function (r, n) {\n  var l = r.children,\n      a = _objectWithoutProperties(r, _excluded2);\n  /*#__PURE__*/\n\n\n  return t.isValidElement(l) ? /*#__PURE__*/t.cloneElement(l, _objectSpread(_objectSpread({}, o(a, l.props)), {}, {\n    ref: e(n, l.ref)\n  })) : t.Children.count(l) > 1 ? t.Children.only(null) : null;\n});\nn.displayName = \"SlotClone\";\nexport var Slottable = function Slottable(_ref) {\n  var e = _ref.children;\n  return /*#__PURE__*/t.createElement(t.Fragment, null, e);\n};\n\nfunction l(e) {\n  /*#__PURE__*/\n  return t.isValidElement(e) && e.type === Slottable;\n}\n\nfunction o(e, t) {\n  var r = _objectSpread({}, t);\n\n  var _loop = function _loop(_n) {\n    var l = e[_n],\n        o = t[_n];\n    /^on[A-Z]/.test(_n) ? r[_n] = function () {\n      null == o || o.apply(void 0, arguments), null == l || l.apply(void 0, arguments);\n    } : \"style\" === _n ? r[_n] = _objectSpread(_objectSpread({}, l), o) : \"className\" === _n && (r[_n] = [l, o].filter(Boolean).join(\" \"));\n  };\n\n  for (var _n in t) {\n    _loop(_n);\n  }\n\n  return _objectSpread(_objectSpread({}, e), r);\n}\n\nexport var Root = Slot;","map":{"version":3,"sources":["packages/react/slot/src/Slot.tsx"],"names":["Slot","React","forwardRef","props","forwardedRef","children","slotProps","childArray","Children","toArray","some","isSlottable","_react","map","child","$d34e8c328cb3dd19ab7a2f6eafa6ad$var$SlotClone","ref","displayName","SlotClone","isValidElement","cloneElement","mergeProps","composeRefs","count","only","Slottable","type","childProps","overrideProps","propName","slotPropValue","childPropValue","test","args","filter","Boolean","join","Root"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childArray = React.Children.toArray(children);\n\n  if (childArray.some(isSlottable)) {\n    return (\n      <>\n        {childArray.map((child) => {\n          return isSlottable(child) ? (\n            <SlotClone {...slotProps} ref={forwardedRef}>\n              {child.props.children}\n            </SlotClone>\n          ) : (\n            child\n          );\n        })}\n      </>\n    );\n  }\n\n  return (\n    <SlotClone {...slotProps} ref={forwardedRef}>\n      {children}\n    </SlotClone>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.isValidElement(children)) {\n    return React.cloneElement(children, {\n      ...mergeProps(slotProps, children.props),\n      ref: composeRefs(forwardedRef, (children as any).ref),\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(child: React.ReactNode): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    // if it's a handler, modify the override by composing the base handler\n    if (isHandler) {\n      overrideProps[propName] = (...args: unknown[]) => {\n        childPropValue?.(...args);\n        slotPropValue?.(...args);\n      };\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\nexport type { SlotProps };\n"]},"metadata":{},"sourceType":"module"}