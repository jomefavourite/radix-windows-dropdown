{"ast":null,"code":"import _toConsumableArray from \"/project/radix-windows-dropdown/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/project/radix-windows-dropdown/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/project/radix-windows-dropdown/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"/project/radix-windows-dropdown/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"loop\", \"trapped\", \"onMountAutoFocus\", \"onUnmountAutoFocus\"];\nimport { useCallbackRef as e } from \"@radix-ui/react-use-callback-ref\";\nimport { Primitive as t } from \"@radix-ui/react-primitive\";\nimport { useComposedRefs as n } from \"@radix-ui/react-compose-refs\";\nimport * as o from \"react\";\nimport u from \"@babel/runtime/helpers/esm/extends\";\nvar c = {\n  bubbles: !1,\n  cancelable: !0\n};\nexport var FocusScope = /*#__PURE__*/o.forwardRef(function (i, f) {\n  var _i$loop = i.loop,\n      l = _i$loop === void 0 ? !1 : _i$loop,\n      _i$trapped = i.trapped,\n      m = _i$trapped === void 0 ? !1 : _i$trapped,\n      p = i.onMountAutoFocus,\n      v = i.onUnmountAutoFocus,\n      E = _objectWithoutProperties(i, _excluded),\n      _o$useState = o.useState(null),\n      _o$useState2 = _slicedToArray(_o$useState, 2),\n      F = _o$useState2[0],\n      S = _o$useState2[1],\n      b = e(p),\n      T = e(v),\n      y = o.useRef(null),\n      L = n(f, function (e) {\n    return S(e);\n  }),\n      h = o.useRef({\n    paused: !1,\n    pause: function pause() {\n      this.paused = !0;\n    },\n    resume: function resume() {\n      this.paused = !1;\n    }\n  }).current;\n\n  o.useEffect(function () {\n    if (m) {\n      var _e = function _e(e) {\n        if (h.paused || !F) return;\n        var t = e.target;\n        F.contains(t) ? y.current = t : a(y.current, {\n          select: !0\n        });\n      };\n\n      var _t = function _t(e) {\n        !h.paused && F && (F.contains(e.relatedTarget) || a(y.current, {\n          select: !0\n        }));\n      };\n\n      return document.addEventListener(\"focusin\", _e), document.addEventListener(\"focusout\", _t), function () {\n        document.removeEventListener(\"focusin\", _e), document.removeEventListener(\"focusout\", _t);\n      };\n    }\n  }, [m, F, h.paused]), o.useEffect(function () {\n    if (F) {\n      d.add(h);\n      var _e2 = document.activeElement;\n\n      if (!F.contains(_e2)) {\n        var _t2 = new Event(\"focusScope.autoFocusOnMount\", c);\n\n        F.addEventListener(\"focusScope.autoFocusOnMount\", b), F.dispatchEvent(_t2), _t2.defaultPrevented || (!function (e) {\n          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n              _ref$select = _ref.select,\n              t = _ref$select === void 0 ? !1 : _ref$select;\n\n          var n = document.activeElement;\n\n          var _iterator = _createForOfIteratorHelper(e),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _o = _step.value;\n              if (a(_o, {\n                select: t\n              }), document.activeElement !== n) return;\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }(r(F), {\n          select: !0\n        }), document.activeElement === _e2 && a(F));\n      }\n\n      return function () {\n        F.removeEventListener(\"focusScope.autoFocusOnMount\", b), setTimeout(function () {\n          var t = new Event(\"focusScope.autoFocusOnUnmount\", c);\n          F.addEventListener(\"focusScope.autoFocusOnUnmount\", T), F.dispatchEvent(t), t.defaultPrevented || a(null != _e2 ? _e2 : document.body, {\n            select: !0\n          }), F.removeEventListener(\"focusScope.autoFocusOnUnmount\", T), d.remove(h);\n        }, 0);\n      };\n    }\n  }, [F, b, T, h]);\n  var x = o.useCallback(function (e) {\n    if (!l && !m) return;\n    if (h.paused) return;\n    var t = \"Tab\" === e.key && !e.altKey && !e.ctrlKey && !e.metaKey,\n        n = document.activeElement;\n\n    if (t && n) {\n      var _t3 = e.currentTarget,\n          _ref2 = function (e) {\n        var t = r(e),\n            n = s(t, e),\n            o = s(t.reverse(), e);\n        return [n, o];\n      }(_t3),\n          _ref3 = _slicedToArray(_ref2, 2),\n          _o2 = _ref3[0],\n          _u = _ref3[1];\n\n      _o2 && _u ? e.shiftKey || n !== _u ? e.shiftKey && n === _o2 && (e.preventDefault(), l && a(_u, {\n        select: !0\n      })) : (e.preventDefault(), l && a(_o2, {\n        select: !0\n      })) : n === _t3 && e.preventDefault();\n    }\n  }, [l, m, h.paused]);\n  /*#__PURE__*/\n\n  return o.createElement(t.div, u({\n    tabIndex: -1\n  }, E, {\n    ref: L,\n    onKeyDown: x\n  }));\n});\n/*#__PURE__*/\n\nfunction r(e) {\n  var t = [],\n      n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: function acceptNode(e) {\n      var t = \"INPUT\" === e.tagName && \"hidden\" === e.type;\n      return e.disabled || e.hidden || t ? NodeFilter.FILTER_SKIP : e.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n\n  for (; n.nextNode();) {\n    t.push(n.currentNode);\n  }\n\n  return t;\n}\n\nfunction s(e, t) {\n  var _iterator2 = _createForOfIteratorHelper(e),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _n = _step2.value;\n      if (!i(_n, {\n        upTo: t\n      })) return _n;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n\nfunction i(e, _ref4) {\n  var t = _ref4.upTo;\n  if (\"hidden\" === getComputedStyle(e).visibility) return !0;\n\n  for (; e;) {\n    if (void 0 !== t && e === t) return !1;\n    if (\"none\" === getComputedStyle(e).display) return !0;\n    e = e.parentElement;\n  }\n\n  return !1;\n}\n\nfunction a(e) {\n  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref5$select = _ref5.select,\n      t = _ref5$select === void 0 ? !1 : _ref5$select;\n\n  if (e && e.focus) {\n    var _n2 = document.activeElement;\n    e.focus({\n      preventScroll: !0\n    }), e !== _n2 && function (e) {\n      return e instanceof HTMLInputElement && \"select\" in e;\n    }(e) && t && e.select();\n  }\n}\n\nvar d = function () {\n  var e = [];\n  return {\n    add: function add(t) {\n      var n = e[0];\n      t !== n && (null == n || n.pause()), e = f(e, t), e.unshift(t);\n    },\n    remove: function remove(t) {\n      var n;\n      e = f(e, t), null === (n = e[0]) || void 0 === n || n.resume();\n    }\n  };\n}();\n\nfunction f(e, t) {\n  var n = _toConsumableArray(e),\n      o = n.indexOf(t);\n\n  return -1 !== o && n.splice(o, 1), n;\n}\n\nexport var Root = FocusScope;","map":{"version":3,"sources":["packages/react/focus-scope/src/FocusScope.tsx"],"names":["EVENT_OPTIONS","bubbles","cancelable","FocusScope","React","forwardRef","props","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","scopeProps","container","setContainer","useState","useCallbackRef","lastFocusedElementRef","useRef","composedRefs","useComposedRefs","node","focusScope","paused","pause","this","resume","current","useEffect","handleFocusIn","event","target","contains","focus","select","handleFocusOut","relatedTarget","document","addEventListener","removeEventListener","focusScopesStack","add","previouslyFocusedElement","activeElement","mountEvent","Event","dispatchEvent","defaultPrevented","focusFirst","getTabbableCandidates","setTimeout","unmountEvent","body","remove","handleKeyDown","useCallback","isTabKey","key","altKey","ctrlKey","metaKey","focusedElement","currentTarget","first","last","getTabbableEdges","preventDefault","shiftKey","_react","Primitive","div","tabIndex","ref","onKeyDown","candidates","candidate","findVisible","reverse","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","elements","element","isHidden","upTo","getComputedStyle","visibility","undefined","display","parentElement","HTMLInputElement","preventScroll","isSelectableInput","createFocusScopesStack","stack","activeFocusScope","arrayRemove","unshift","array","item","updatedArray","index","indexOf","splice","Root"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        if (!container.contains(event.relatedTarget as HTMLElement | null)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new Event(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(getTabbableCandidates(container), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new Event(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n"]},"metadata":{},"sourceType":"module"}