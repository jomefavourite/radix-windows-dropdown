{"mappings":"IAYgCA,EAAMC,oEAAND,KAAMC,mBACpCC,OAAOC,KAAKF,GAAQG,SAAQ,SAASC,GACvB,YAARA,GAA6B,eAARA,GAIzBH,OAAOI,eAAeN,EAAMK,EAAK,CAC/BE,YAAY,EACZC,IAAK,WACH,OAAOP,EAAOI,SAKbL,GCvBT,IACIS,EADAC,EAAc,+BAGlB,UAA8BC,SAAEA,IAC9B,MAAMC,EAAyBC,EAAMC,QAAO,GACtCC,EAAwBF,EAAMC,QAAO,GAE3CD,EAAMG,WAAU,KACd,MAAMC,EAAqBC,IACzB,MAAMC,EAAgC,UAAtBD,EAAME,YACtBR,EAAuBS,SAAWF,EAClCJ,EAAsBM,QAAUF,GAA4B,IAAjBD,EAAMI,QAE7CC,EAAkB,KACtBX,EAAuBS,SAAU,EACjCN,EAAsBM,SAAU,GAIlC,OAFAG,SAASC,iBAAiB,cAAeR,GACzCO,SAASC,iBAAiB,YAAaF,GAChC,KACLC,SAASE,oBAAoB,cAAeT,GAC5CO,SAASE,oBAAoB,YAAaH,MAE3C,IAEHI,GAAgB,KACd,GAAIhB,EAAU,CAKZ,SAASiB,IACPlB,IACoB,IAAhBA,IACFc,SAASK,KAAKC,MAAMC,cAAgBtB,GAOxC,OAdoB,IAAhBC,IACFD,EAA4Be,SAASK,KAAKC,MAAMC,eAUlDP,SAASK,KAAKC,MAAMC,cAAgB,OACpCrB,IAEO,KACDE,EAAuBS,QAkBzBG,SAASC,iBAAiB,QAASG,EAAoB,CAAEI,MAAM,IACtDjB,EAAsBM,QAM/BG,SAASC,iBAAiB,YAAaG,EAAoB,CAAEI,MAAM,IAEnEJ,QAIL,CAACjB","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/use-body-pointer-events/src/useBodyPointerEvents.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\nlet changeCount = 0;\nlet originalBodyPointerEvents: string;\n\nfunction useBodyPointerEvents({ disabled }: { disabled: boolean }) {\n  const isTouchOrPenPressedRef = React.useRef(false);\n  const isMouseLeftPressedRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      const isMouse = event.pointerType === 'mouse';\n      isTouchOrPenPressedRef.current = !isMouse;\n      isMouseLeftPressedRef.current = isMouse && event.button === 0;\n    };\n    const handlePointerUp = () => {\n      isTouchOrPenPressedRef.current = false;\n      isMouseLeftPressedRef.current = false;\n    };\n    document.addEventListener('pointerdown', handlePointerDown);\n    document.addEventListener('pointerup', handlePointerUp);\n    return () => {\n      document.removeEventListener('pointerdown', handlePointerDown);\n      document.removeEventListener('pointerup', handlePointerUp);\n    };\n  }, []);\n\n  useLayoutEffect(() => {\n    if (disabled) {\n      if (changeCount === 0) {\n        originalBodyPointerEvents = document.body.style.pointerEvents;\n      }\n\n      function resetPointerEvents() {\n        changeCount--;\n        if (changeCount === 0) {\n          document.body.style.pointerEvents = originalBodyPointerEvents;\n        }\n      }\n\n      document.body.style.pointerEvents = 'none';\n      changeCount++;\n\n      return () => {\n        if (isTouchOrPenPressedRef.current) {\n          /**\n           * We force pointer-events to remain disabled until `click` fires on touch devices\n           * because browsers implement a ~350ms delay between the time the user stops\n           * touching the display and when the browser executes events. We need to ensure we\n           * don't reactivate pointer-events within this timeframe otherwise the browser may\n           * execute events that should have been prevented.\n           *\n           * We are aware that `touch-action: manipulation` shortens this delay for events,\n           * but it isn't enough to cover all cases.\n           *\n           * When there is an input on screen:\n           * - if a click event is bound to it, it will fire after a `pointerdown` which may\n           * have re-enabled pointer-events (regardless of `touch-action: manipulation`).\n           * - if clicking it causes the page to zoom, the events will wait for the zoom to\n           * finish before executing on the input.\n           * - if long pressesing it, the events will execute after the longpress delay.\n           */\n          document.addEventListener('click', resetPointerEvents, { once: true });\n        } else if (isMouseLeftPressedRef.current) {\n          /**\n           * We force pointer-events to remain disabled until `pointerup` otherwise, events\n           * bound to inert controls could execute after pointer-events have been re-enabled,\n           * e.g. `select` event.\n           */\n          document.addEventListener('pointerup', resetPointerEvents, { once: true });\n        } else {\n          resetPointerEvents();\n        }\n      };\n    }\n  }, [disabled]);\n}\n\nexport { useBodyPointerEvents };\n"],"names":["dest","source","Object","keys","forEach","key","defineProperty","enumerable","get","originalBodyPointerEvents","changeCount","disabled","isTouchOrPenPressedRef","React","useRef","isMouseLeftPressedRef","useEffect","handlePointerDown","event","isMouse","pointerType","current","button","handlePointerUp","document","addEventListener","removeEventListener","useLayoutEffect","resetPointerEvents","body","style","pointerEvents","once"],"version":3,"file":"index.js.map"}