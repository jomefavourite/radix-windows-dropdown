{"mappings":"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","sources":["./packages/react/menu/src/Menu.tsx"],"sourcesContent":["import * as React from 'react';\nimport { RemoveScroll } from 'react-remove-scroll';\nimport { hideOthers } from 'aria-hidden';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs, composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { useDirection } from '@radix-ui/react-use-direction';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { useId } from '@radix-ui/react-id';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst SELECTION_KEYS = ['Enter', ' '];\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nconst SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n};\nconst SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype ItemData = { disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenuItemElement,\n  ItemData\n>(MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenu?: Scope };\nconst [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [\n  createCollectionScope,\n  createPopperScope,\n  createRovingFocusGroupScope,\n]);\nconst usePopperScope = createPopperScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenuRootContextValue = {\n  isSubmenu: false;\n  isUsingKeyboardRef: React.RefObject<boolean>;\n  dir: Direction;\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  content: MenuContentElement | null;\n  onContentChange(content: MenuContentElement | null): void;\n  onRootClose(): void;\n  modal: boolean;\n};\n\ntype MenuSubContextValue = Omit<MenuRootContextValue, 'isSubmenu'> & {\n  isSubmenu: true;\n  contentId: string;\n  triggerId: string;\n  trigger: MenuSubTriggerElement | null;\n  onTriggerChange(trigger: MenuSubTriggerElement | null): void;\n};\n\nconst [MenuProvider, useMenuContext] = createMenuContext<\n  MenuRootContextValue | MenuSubContextValue\n>(MENU_NAME);\n\ninterface MenuProps {\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  modal?: boolean;\n  children?: React.ReactNode;\n}\n\nconst Menu: React.FC<MenuProps> = (props: ScopedProps<MenuProps>) => {\n  const { __scopeMenu, open = false, children, onOpenChange, modal = true } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const computedDirection = useDirection(content, props.dir);\n\n  React.useEffect(() => {\n    const handleKeyDown = () => (isUsingKeyboardRef.current = true);\n    const handlePointer = () => (isUsingKeyboardRef.current = false);\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    document.addEventListener('keydown', handleKeyDown, { capture: true });\n    document.addEventListener('pointerdown', handlePointer, { capture: true });\n    document.addEventListener('pointermove', handlePointer, { capture: true });\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, { capture: true });\n      document.removeEventListener('pointerdown', handlePointer, { capture: true });\n      document.removeEventListener('pointermove', handlePointer, { capture: true });\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        isSubmenu={false}\n        isUsingKeyboardRef={isUsingKeyboardRef}\n        dir={computedDirection}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n        onRootClose={React.useCallback(() => handleOpenChange(false), [handleOpenChange])}\n        modal={modal}\n      >\n        {children}\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst SUB_NAME = 'MenuSub';\n\ninterface MenuSubProps {\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  children?: React.ReactNode;\n}\n\nconst MenuSub: React.FC<MenuSubProps> = (props: ScopedProps<MenuSubProps>) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState<MenuSubTriggerElement | null>(null);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n\n  // Prevent the parent menu from reopening with open submenus.\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        isSubmenu={true}\n        isUsingKeyboardRef={parentMenuContext.isUsingKeyboardRef}\n        dir={parentMenuContext.dir}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n        onRootClose={parentMenuContext.onRootClose}\n        contentId={useId()}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        triggerId={useId()}\n        modal={false}\n      >\n        {children}\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenuSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'MenuAnchor';\n\ntype MenuAnchorElement = React.ElementRef<typeof PopperPrimitive.Anchor>;\ntype PopperAnchorProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst MenuAnchor = React.forwardRef<MenuAnchorElement, MenuAnchorProps>(\n  (props: ScopedProps<MenuAnchorProps>, forwardedRef) => {\n    const { __scopeMenu, ...anchorProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Anchor {...popperScope} {...anchorProps} ref={forwardedRef} />;\n  }\n);\n\nMenuAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype MenuContentContextValue = {\n  onItemEnter(event: React.PointerEvent): void;\n  onItemLeave(event: React.PointerEvent): void;\n  onTriggerLeave(event: React.PointerEvent): void;\n  searchRef: React.RefObject<string>;\n  pointerGraceTimerRef: React.MutableRefObject<number>;\n  onPointerGraceIntentChange(intent: GraceIntent | null): void;\n};\nconst [MenuContentProvider, useMenuContentContext] =\n  createMenuContext<MenuContentContextValue>(CONTENT_NAME);\n\ntype MenuContentElement = MenuRootContentElement | MenuSubContentElement;\n/**\n * We purposefully don't union MenuRootContent and MenuSubContent props here because\n * they have conflicting prop types. We agreed that we would allow MenuSubContent to\n * accept props that it would just ignore.\n */\ninterface MenuContentProps extends MenuRootContentProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuContent = React.forwardRef<MenuContentElement, MenuContentProps>(\n  (props: ScopedProps<MenuContentProps>, forwardedRef) => {\n    const { forceMount, ...contentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            {context.isSubmenu ? (\n              <MenuSubContent {...contentProps} ref={forwardedRef} />\n            ) : (\n              <MenuRootContent {...contentProps} ref={forwardedRef} />\n            )}\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuRootContentElement = MenuRootContentTypeElement;\ninterface MenuRootContentProps\n  extends Omit<MenuRootContentTypeProps, keyof MenuContentImplPrivateProps> {}\n\nconst MenuRootContent = React.forwardRef<MenuRootContentElement, MenuRootContentProps>(\n  (props: ScopedProps<MenuRootContentProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    return context.modal ? (\n      <MenuRootContentModal {...props} ref={forwardedRef} />\n    ) : (\n      <MenuRootContentNonModal {...props} ref={forwardedRef} />\n    );\n  }\n);\n\ntype MenuRootContentTypeElement = MenuContentImplElement;\ninterface MenuRootContentTypeProps\n  extends Omit<\n    MenuContentImplProps,\n    'trapFocus' | 'disableOutsidePointerEvents' | 'disableOutsideScroll'\n  > {}\n\nconst MenuRootContentModal = React.forwardRef<MenuRootContentTypeElement, MenuRootContentTypeProps>(\n  (props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuRootContentTypeElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // Hide everything from ARIA except the `MenuContent`\n    React.useEffect(() => {\n      const content = ref.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <MenuContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure we're not trapping once it's been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        // make sure to only disable pointer events when open\n        // this avoids blocking interactions while animating out\n        disableOutsidePointerEvents={context.open}\n        disableOutsideScroll\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault(),\n          { checkForDefaultPrevented: false }\n        )}\n        onDismiss={() => context.onOpenChange(false)}\n      />\n    );\n  }\n);\n\nconst MenuRootContentNonModal = React.forwardRef<\n  MenuRootContentTypeElement,\n  MenuRootContentTypeProps\n>((props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return (\n    <MenuContentImpl\n      {...props}\n      ref={forwardedRef}\n      trapFocus={false}\n      disableOutsidePointerEvents={false}\n      disableOutsideScroll={false}\n      onDismiss={() => context.onOpenChange(false)}\n    />\n  );\n});\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuSubContentElement = MenuContentImplElement;\ninterface MenuSubContentProps\n  extends Omit<\n    MenuContentImplProps,\n    | keyof MenuContentImplPrivateProps\n    | 'align'\n    | 'side'\n    | 'portalled'\n    | 'disabledOutsidePointerEvents'\n    | 'disableOutsideScroll'\n    | 'trapFocus'\n    | 'onCloseAutoFocus'\n  > {}\n\nconst MenuSubContent = React.forwardRef<MenuSubContentElement, MenuSubContentProps>(\n  (props: ScopedProps<MenuSubContentProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuSubContentElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    return context.isSubmenu ? (\n      <MenuContentImpl\n        id={context.contentId}\n        aria-labelledby={context.triggerId}\n        {...props}\n        ref={composedRefs}\n        align=\"start\"\n        side={context.dir === 'rtl' ? 'left' : 'right'}\n        portalled\n        disableOutsidePointerEvents={false}\n        disableOutsideScroll={false}\n        trapFocus={false}\n        onOpenAutoFocus={(event) => {\n          // when opening a submenu, focus content for keyboard users only\n          if (context.isUsingKeyboardRef.current) ref.current?.focus();\n          event.preventDefault();\n        }}\n        // The menu might close because of focusing another menu item in the parent menu. We\n        // don't want it to refocus the trigger in that case so we handle trigger focus ourselves.\n        onCloseAutoFocus={(event) => event.preventDefault()}\n        onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n          // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n          // on pointer interaction.\n          if (event.target !== context.trigger) context.onOpenChange(false);\n        })}\n        onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, context.onRootClose)}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          // Submenu key events bubble through portals. We only care about keys in this menu.\n          const isKeyDownInside = event.currentTarget.contains(event.target as HTMLElement);\n          const isCloseKey = SUB_CLOSE_KEYS[context.dir].includes(event.key);\n          if (isKeyDownInside && isCloseKey) {\n            context.onOpenChange(false);\n            // We focus manually because we prevented it in `onCloseAutoFocus`\n            context.trigger?.focus();\n            // prevent window from scrolling\n            event.preventDefault();\n          }\n        })}\n      />\n    ) : null;\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype RemoveScrollProps = React.ComponentProps<typeof RemoveScroll>;\ntype MenuContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype FocusScopeProps = Radix.ComponentPropsWithoutRef<typeof FocusScope>;\ntype DismissableLayerProps = Radix.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype RovingFocusGroupProps = Radix.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PopperContentProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ntype MenuContentImplPrivateProps = {\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n  onDismiss?: DismissableLayerProps['onDismiss'];\n};\ninterface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n    PopperContentProps,\n    Omit<DismissableLayerProps, 'onDismiss'> {\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * (default: false)\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n  /**\n   * @see https://github.com/theKashey/react-remove-scroll#usage\n   */\n  allowPinchZoom?: RemoveScrollProps['allowPinchZoom'];\n\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * (default: `false`)\n   */\n  disableOutsideScroll?: boolean;\n\n  /**\n   * The direction of navigation between menu items.\n   * @defaultValue ltr\n   */\n  dir?: RovingFocusGroupProps['dir'];\n\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: RovingFocusGroupProps['loop'];\n\n  /**\n   * Whether the `MenuContent` should render in a `Portal`\n   * (default: `true`)\n   */\n  portalled?: boolean;\n}\n\nconst MenuContentImpl = React.forwardRef<MenuContentImplElement, MenuContentImplProps>(\n  (props: ScopedProps<MenuContentImplProps>, forwardedRef) => {\n    const {\n      __scopeMenu,\n      loop = false,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      disableOutsideScroll,\n      allowPinchZoom,\n      portalled,\n      ...contentProps\n    } = props;\n    const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n    const popperScope = usePopperScope(__scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const getItems = useCollection(__scopeMenu);\n    const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n    const timerRef = React.useRef(0);\n    const searchRef = React.useRef('');\n    const pointerGraceTimerRef = React.useRef(0);\n    const pointerGraceIntentRef = React.useRef<GraceIntent | null>(null);\n    const pointerDirRef = React.useRef<Side>('right');\n    const lastPointerXRef = React.useRef(0);\n\n    const PortalWrapper = portalled ? Portal : React.Fragment;\n    const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n    const scrollLockWrapperProps = disableOutsideScroll ? { allowPinchZoom } : undefined;\n\n    const handleTypeaheadSearch = (key: string) => {\n      const search = searchRef.current + key;\n      const items = getItems().filter((item) => !item.disabled);\n      const currentItem = document.activeElement;\n      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;\n      const values = items.map((item) => item.textValue);\n      const nextMatch = getNextMatch(values, search, currentMatch);\n      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;\n\n      // Reset `searchRef` 1 second after it was last updated\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n\n      if (newItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (newItem as HTMLElement).focus());\n      }\n    };\n\n    React.useEffect(() => {\n      return () => window.clearTimeout(timerRef.current);\n    }, []);\n\n    // Make sure the whole tree has focus guards as our `MenuContent` may be\n    // the last element in the DOM (beacuse of the `Portal`)\n    useFocusGuards();\n\n    const isPointerMovingToSubmenu = React.useCallback((event: React.PointerEvent) => {\n      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n    }, []);\n\n    return (\n      <PortalWrapper>\n        <ScrollLockWrapper {...scrollLockWrapperProps}>\n          <MenuContentProvider\n            scope={__scopeMenu}\n            searchRef={searchRef}\n            onItemEnter={React.useCallback(\n              (event) => {\n                if (isPointerMovingToSubmenu(event)) event.preventDefault();\n              },\n              [isPointerMovingToSubmenu]\n            )}\n            onItemLeave={React.useCallback(\n              (event) => {\n                if (isPointerMovingToSubmenu(event)) return;\n                contentRef.current?.focus();\n                setCurrentItemId(null);\n              },\n              [isPointerMovingToSubmenu]\n            )}\n            onTriggerLeave={React.useCallback(\n              (event) => {\n                if (isPointerMovingToSubmenu(event)) event.preventDefault();\n              },\n              [isPointerMovingToSubmenu]\n            )}\n            pointerGraceTimerRef={pointerGraceTimerRef}\n            onPointerGraceIntentChange={React.useCallback((intent) => {\n              pointerGraceIntentRef.current = intent;\n            }, [])}\n          >\n            <FocusScope\n              asChild\n              trapped={trapFocus}\n              onMountAutoFocus={composeEventHandlers(onOpenAutoFocus, (event) => {\n                // when opening, explicitly focus the content area only and leave\n                // `onEntryFocus` in  control of focusing first item\n                event.preventDefault();\n                contentRef.current?.focus();\n              })}\n              onUnmountAutoFocus={onCloseAutoFocus}\n            >\n              <DismissableLayer\n                asChild\n                disableOutsidePointerEvents={disableOutsidePointerEvents}\n                onEscapeKeyDown={onEscapeKeyDown}\n                onPointerDownOutside={onPointerDownOutside}\n                onFocusOutside={onFocusOutside}\n                onInteractOutside={onInteractOutside}\n                onDismiss={onDismiss}\n              >\n                <RovingFocusGroup.Root\n                  asChild\n                  {...rovingFocusGroupScope}\n                  dir={context.dir}\n                  orientation=\"vertical\"\n                  loop={loop}\n                  currentTabStopId={currentItemId}\n                  onCurrentTabStopIdChange={setCurrentItemId}\n                  onEntryFocus={(event) => {\n                    // only focus first item when using keyboard\n                    if (!context.isUsingKeyboardRef.current) event.preventDefault();\n                  }}\n                >\n                  <PopperPrimitive.Content\n                    role=\"menu\"\n                    dir={context.dir}\n                    data-state={getOpenState(context.open)}\n                    {...popperScope}\n                    {...contentProps}\n                    ref={composedRefs}\n                    style={{ outline: 'none', ...contentProps.style }}\n                    onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                      // submenu key events bubble through portals. We only care about keys in this menu.\n                      const target = event.target as HTMLElement;\n                      const isKeyDownInside = event.currentTarget.contains(target);\n                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                      if (isKeyDownInside && !isModifierKey && event.key.length === 1) {\n                        handleTypeaheadSearch(event.key);\n                      }\n                      // menus should not be navigated using tab key so we prevent it\n                      if (event.key === 'Tab') event.preventDefault();\n                      // focus first/last item based on key pressed\n                      const content = contentRef.current;\n                      if (event.target !== content) return;\n                      if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                      event.preventDefault();\n                      const items = getItems().filter((item) => !item.disabled);\n                      const candidateNodes = items.map((item) => item.ref.current!);\n                      if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                      focusFirst(candidateNodes);\n                    })}\n                    onBlur={composeEventHandlers(props.onBlur, (event) => {\n                      // clear search buffer when leaving the menu\n                      if (!event.currentTarget.contains(event.target)) {\n                        window.clearTimeout(timerRef.current);\n                        searchRef.current = '';\n                      }\n                    })}\n                    onPointerMove={composeEventHandlers(\n                      props.onPointerMove,\n                      whenMouse((event) => {\n                        const target = event.target as HTMLElement;\n                        const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                        // We don't use `event.movementX` for this check because Safari will\n                        // always return `0` on a pointer event.\n                        if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                          const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';\n                          pointerDirRef.current = newDir;\n                          lastPointerXRef.current = event.clientX;\n                        }\n                      })\n                    )}\n                  />\n                </RovingFocusGroup.Root>\n              </DismissableLayer>\n            </FocusScope>\n          </MenuContentProvider>\n        </ScrollLockWrapper>\n      </PortalWrapper>\n    );\n  }\n);\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenuGroup';\n\ntype MenuGroupElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenuGroupProps extends PrimitiveDivProps {}\n\nconst MenuGroup = React.forwardRef<MenuGroupElement, MenuGroupProps>(\n  (props: ScopedProps<MenuGroupProps>, forwardedRef) => {\n    const { __scopeMenu, ...groupProps } = props;\n    return <Primitive.div role=\"group\" {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenuLabel';\n\ntype MenuLabelElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuLabelProps extends PrimitiveDivProps {}\n\nconst MenuLabel = React.forwardRef<MenuLabelElement, MenuLabelProps>(\n  (props: ScopedProps<MenuLabelProps>, forwardedRef) => {\n    const { __scopeMenu, ...labelProps } = props;\n    return <Primitive.div {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemElement = MenuItemImplElement;\ninterface MenuItemProps extends Omit<MenuItemImplProps, 'onSelect'> {\n  onSelect?: (event: Event) => void;\n}\n\nconst MenuItem = React.forwardRef<MenuItemElement, MenuItemProps>(\n  (props: ScopedProps<MenuItemProps>, forwardedRef) => {\n    const { disabled = false, onSelect, ...itemProps } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const context = useMenuContext(ITEM_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isPointerDownRef = React.useRef(false);\n\n    const handleSelect = () => {\n      const menuItem = ref.current;\n      if (!disabled && menuItem) {\n        const itemSelectEvent = new Event(ITEM_SELECT, { bubbles: true, cancelable: true });\n        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });\n        menuItem.dispatchEvent(itemSelectEvent);\n        if (itemSelectEvent.defaultPrevented) {\n          isPointerDownRef.current = false;\n        } else {\n          context.onRootClose();\n        }\n      }\n    };\n\n    return (\n      <MenuItemImpl\n        {...itemProps}\n        ref={composedRefs}\n        disabled={disabled}\n        onClick={composeEventHandlers(props.onClick, handleSelect)}\n        onPointerDown={(event) => {\n          props.onPointerDown?.(event);\n          isPointerDownRef.current = true;\n        }}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          // Pointer down can move to a different menu item which should activate it on pointer up.\n          // We dispatch a click for selection to allow composition with click based triggers and to\n          // prevent Firefox from getting stuck in text selection mode when the menu closes.\n          if (!isPointerDownRef.current) event.currentTarget?.click();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isTypingAhead = contentContext.searchRef.current !== '';\n          if (disabled || (isTypingAhead && event.key === ' ')) return;\n          if (SELECTION_KEYS.includes(event.key)) {\n            event.currentTarget.click();\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            event.preventDefault();\n          }\n        })}\n      />\n    );\n  }\n);\n\nMenuItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenuSubTrigger';\n\ntype MenuSubTriggerElement = MenuItemImplElement;\ninterface MenuSubTriggerProps extends MenuItemImplProps {}\n\nconst MenuSubTrigger = React.forwardRef<MenuSubTriggerElement, MenuSubTriggerProps>(\n  (props: ScopedProps<MenuSubTriggerProps>, forwardedRef) => {\n    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const openTimerRef = React.useRef<number | null>(null);\n    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n\n    const clearOpenTimer = React.useCallback(() => {\n      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n      openTimerRef.current = null;\n    }, []);\n\n    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n\n    React.useEffect(() => {\n      const pointerGraceTimer = pointerGraceTimerRef.current;\n      return () => {\n        window.clearTimeout(pointerGraceTimer);\n        onPointerGraceIntentChange(null);\n      };\n    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n\n    return context.isSubmenu ? (\n      <MenuAnchor asChild {...props}>\n        <MenuItemImpl\n          id={context.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={context.contentId}\n          data-state={getOpenState(context.open)}\n          {...props}\n          ref={composeRefs(forwardedRef, context.onTriggerChange)}\n          // This is redundant for mouse users but we cannot determine pointer type from\n          // click event and we cannot use pointerup event (see git history for reasons why)\n          onClick={(event) => {\n            props.onClick?.(event);\n            if (props.disabled || event.defaultPrevented) return;\n            /**\n             * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n             * and we rely heavily on `onFocusOutside` for submenus to close when switching\n             * between separate submenus.\n             */\n            event.currentTarget.focus();\n            if (!context.open) context.onOpenChange(true);\n          }}\n          onPointerMove={composeEventHandlers(\n            props.onPointerMove,\n            whenMouse((event) => {\n              contentContext.onItemEnter(event);\n              if (event.defaultPrevented) return;\n              if (!props.disabled && !context.open && !openTimerRef.current) {\n                contentContext.onPointerGraceIntentChange(null);\n                openTimerRef.current = window.setTimeout(() => {\n                  context.onOpenChange(true);\n                  clearOpenTimer();\n                }, 100);\n              }\n            })\n          )}\n          onPointerLeave={composeEventHandlers(\n            props.onPointerLeave,\n            whenMouse((event) => {\n              clearOpenTimer();\n\n              const contentRect = context.content?.getBoundingClientRect();\n              if (contentRect) {\n                // TODO: make sure to update this when we change positioning logic\n                const side = context.content?.dataset.side as Side;\n                const rightSide = side === 'right';\n                const bleed = rightSide ? -5 : +5;\n                const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n\n                contentContext.onPointerGraceIntentChange({\n                  area: [\n                    // Apply a bleed on clientX to ensure that our exit point is\n                    // consistently within polygon bounds\n                    { x: event.clientX + bleed, y: event.clientY },\n                    { x: contentNearEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.bottom },\n                    { x: contentNearEdge, y: contentRect.bottom },\n                  ],\n                  side,\n                });\n\n                window.clearTimeout(pointerGraceTimerRef.current);\n                pointerGraceTimerRef.current = window.setTimeout(\n                  () => contentContext.onPointerGraceIntentChange(null),\n                  300\n                );\n              } else {\n                contentContext.onTriggerLeave(event);\n                if (event.defaultPrevented) return;\n\n                // There's 100ms where the user may leave an item before the submenu was opened.\n                contentContext.onPointerGraceIntentChange(null);\n              }\n            })\n          )}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isTypingAhead = contentContext.searchRef.current !== '';\n            if (props.disabled || (isTypingAhead && event.key === ' ')) return;\n            if (SUB_OPEN_KEYS[context.dir].includes(event.key)) {\n              context.onOpenChange(true);\n              // The trigger may hold focus if opened via pointer interaction\n              // so we ensure content is given focus again when switching to keyboard.\n              context.content?.focus();\n              // prevent window from scrolling\n              event.preventDefault();\n            }\n          })}\n        />\n      </MenuAnchor>\n    ) : null;\n  }\n);\n\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuItemImplElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuItemImplProps extends PrimitiveDivProps {\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst MenuItemImpl = React.forwardRef<MenuItemImplElement, MenuItemImplProps>(\n  (props: ScopedProps<MenuItemImplProps>, forwardedRef) => {\n    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n    const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const ref = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // get the item's `.textContent` as default strategy for typeahead `textValue`\n    const [textContent, setTextContent] = React.useState('');\n    React.useEffect(() => {\n      const menuItem = ref.current;\n      if (menuItem) {\n        setTextContent((menuItem.textContent ?? '').trim());\n      }\n    }, [itemProps.children]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeMenu}\n        disabled={disabled}\n        textValue={textValue ?? textContent}\n      >\n        <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!disabled}>\n          <Primitive.div\n            role=\"menuitem\"\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            {...itemProps}\n            ref={composedRefs}\n            /**\n             * We focus items on `pointerMove` to achieve the following:\n             *\n             * - Mouse over an item (it focuses)\n             * - Leave mouse where it is and use keyboard to focus a different item\n             * - Wiggle mouse without it leaving previously focused item\n             * - Previously focused item should re-focus\n             *\n             * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n             * wiggles. This is to match native menu implementation.\n             */\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse((event) => {\n                if (disabled) {\n                  contentContext.onItemLeave(event);\n                } else {\n                  contentContext.onItemEnter(event);\n                  if (!event.defaultPrevented) {\n                    const item = event.currentTarget;\n                    item.focus();\n                  }\n                }\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse((event) => contentContext.onItemLeave(event))\n            )}\n          />\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemElement = MenuItemElement;\ninterface MenuCheckboxItemProps extends MenuItemProps {\n  checked?: boolean;\n  onCheckedChange?: (checked: boolean) => void;\n}\n\nconst MenuCheckboxItem = React.forwardRef<MenuCheckboxItemElement, MenuCheckboxItemProps>(\n  (props: ScopedProps<MenuCheckboxItemProps>, forwardedRef) => {\n    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemcheckbox\"\n          aria-checked={checked}\n          {...checkboxItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            checkboxItemProps.onSelect,\n            () => onCheckedChange?.(!checked),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst [RadioGroupProvider, useRadioGroupContext] = createMenuContext<MenuRadioGroupProps>(\n  RADIO_GROUP_NAME,\n  { value: undefined, onValueChange: () => {} }\n);\n\ntype MenuRadioGroupElement = React.ElementRef<typeof MenuGroup>;\ninterface MenuRadioGroupProps extends MenuGroupProps {\n  value?: string;\n  onValueChange?: (value: string) => void;\n}\n\nconst MenuRadioGroup = React.forwardRef<MenuRadioGroupElement, MenuRadioGroupProps>(\n  (props: ScopedProps<MenuRadioGroupProps>, forwardedRef) => {\n    const { value, onValueChange, ...groupProps } = props;\n    const handleValueChange = useCallbackRef(onValueChange);\n    return (\n      <RadioGroupProvider scope={props.__scopeMenu} value={value} onValueChange={handleValueChange}>\n        <MenuGroup {...groupProps} ref={forwardedRef} />\n      </RadioGroupProvider>\n    );\n  }\n);\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemElement = React.ElementRef<typeof MenuItem>;\ninterface MenuRadioItemProps extends MenuItemProps {\n  value: string;\n}\n\nconst MenuRadioItem = React.forwardRef<MenuRadioItemElement, MenuRadioItemProps>(\n  (props: ScopedProps<MenuRadioItemProps>, forwardedRef) => {\n    const { value, ...radioItemProps } = props;\n    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n    const checked = value === context.value;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemradio\"\n          aria-checked={checked}\n          {...radioItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            radioItemProps.onSelect,\n            () => context.onValueChange?.(value),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\n\nconst [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(ITEM_INDICATOR_NAME, {\n  checked: false,\n});\n\ntype MenuItemIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface MenuItemIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuItemIndicator = React.forwardRef<MenuItemIndicatorElement, MenuItemIndicatorProps>(\n  (props: ScopedProps<MenuItemIndicatorProps>, forwardedRef) => {\n    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n    return (\n      <Presence present={forceMount || indicatorContext.checked}>\n        <Primitive.span\n          {...itemIndicatorProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(indicatorContext.checked)}\n        />\n      </Presence>\n    );\n  }\n);\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenuSeparator';\n\ntype MenuSeparatorElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuSeparatorProps extends PrimitiveDivProps {}\n\nconst MenuSeparator = React.forwardRef<MenuSeparatorElement, MenuSeparatorProps>(\n  (props: ScopedProps<MenuSeparatorProps>, forwardedRef) => {\n    const { __scopeMenu, ...separatorProps } = props;\n    return (\n      <Primitive.div\n        role=\"separator\"\n        aria-orientation=\"horizontal\"\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenuArrow';\n\ntype MenuArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface MenuArrowProps extends PopperArrowProps {}\n\nconst MenuArrow = React.forwardRef<MenuArrowElement, MenuArrowProps>(\n  (props: ScopedProps<MenuArrowProps>, forwardedRef) => {\n    const { __scopeMenu, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenuArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction getCheckedState(checked: boolean) {\n  return checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\ntype Side = 'left' | 'right';\ntype GraceIntent = { area: Polygon; side: Side };\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event: React.PointerEvent, area?: Polygon) {\n  if (!area) return false;\n  const cursorPos = { x: event.clientX, y: event.clientY };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\nconst Root = Menu;\nconst Sub = MenuSub;\nconst Anchor = MenuAnchor;\nconst SubTrigger = MenuSubTrigger;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\n\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuSub,\n  MenuAnchor,\n  MenuSubTrigger,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  //\n  Root,\n  Sub,\n  Anchor,\n  SubTrigger,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n};\nexport type {\n  MenuProps,\n  MenuSubProps,\n  MenuAnchorProps,\n  MenuSubTriggerProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n};\n"],"names":["SELECTION_KEYS","LAST_KEYS","FIRST_LAST_KEYS","SUB_OPEN_KEYS","ltr","rtl","SUB_CLOSE_KEYS","Collection","useCollection","createCollectionScope","createCollection","createMenuContext","createMenuScope","createContextScope","createPopperScope","createRovingFocusGroupScope","usePopperScope","useRovingFocusGroupScope","MenuProvider","useMenuContext","Menu","props","__scopeMenu","open","children","onOpenChange","modal","popperScope","content","setContent","React","useState","isUsingKeyboardRef","useRef","handleOpenChange","useCallbackRef","computedDirection","useDirection","dir","useEffect","handleKeyDown","current","handlePointer","document","addEventListener","capture","removeEventListener","_react","createElement","_radixUiReactPopper","Root","$e9e2cf92950df0b951e7bac95d18$var$MenuProvider","scope","isSubmenu","onContentChange","onRootClose","useCallback","MenuSub","parentMenuContext","trigger","setTrigger","contentId","useId","onTriggerChange","triggerId","MenuAnchor","forwardRef","forwardedRef","anchorProps","Anchor","_babelRuntimeHelpersEsmExtends","ref","MenuContentProvider","useMenuContentContext","MenuContent","forceMount","contentProps","context","$e9e2cf92950df0b951e7bac95d18$var$Collection","Provider","Presence","present","Slot","$e9e2cf92950df0b951e7bac95d18$var$MenuSubContent","$e9e2cf92950df0b951e7bac95d18$var$MenuRootContent","MenuRootContent","$e9e2cf92950df0b951e7bac95d18$var$MenuRootContentModal","$e9e2cf92950df0b951e7bac95d18$var$MenuRootContentNonModal","MenuRootContentModal","composedRefs","useComposedRefs","hideOthers","$e9e2cf92950df0b951e7bac95d18$var$MenuContentImpl","trapFocus","disableOutsidePointerEvents","disableOutsideScroll","onFocusOutside","composeEventHandlers","event","preventDefault","checkForDefaultPrevented","onDismiss","MenuRootContentNonModal","MenuSubContent","id","align","side","portalled","onOpenAutoFocus","_ref$current","focus","onCloseAutoFocus","target","onEscapeKeyDown","onKeyDown","isKeyDownInside","currentTarget","contains","isCloseKey","includes","key","_context$trigger","MenuContentImpl","loop","onPointerDownOutside","onInteractOutside","allowPinchZoom","rovingFocusGroupScope","getItems","currentItemId","setCurrentItemId","contentRef","timerRef","searchRef","pointerGraceTimerRef","pointerGraceIntentRef","pointerDirRef","lastPointerXRef","PortalWrapper","Portal","Fragment","ScrollLockWrapper","RemoveScroll","scrollLockWrapperProps","undefined","handleTypeaheadSearch","_items$find","_items$find2","search","items","filter","item","disabled","currentItem","activeElement","currentMatch","find","textValue","nextMatch","values","normalizedSearch","length","Array","from","every","char","currentMatchIndex","indexOf","wrappedValues","array","startIndex","Math","max","map","_","index","v","value","toLowerCase","startsWith","getNextMatch","newItem","updateSearch","window","clearTimeout","setTimeout","useFocusGuards","isPointerMovingToSubmenu","_pointerGraceIntentRe","_pointerGraceIntentRe2","area","point","polygon","x","y","inside","i","j","xi","yi","xj","yj","isPointInPolygon","clientX","clientY","isPointerInGraceArea","$e9e2cf92950df0b951e7bac95d18$var$MenuContentProvider","onItemEnter","onItemLeave","_contentRef$current","onTriggerLeave","onPointerGraceIntentChange","intent","FocusScope","asChild","trapped","onMountAutoFocus","_contentRef$current2","onUnmountAutoFocus","DismissableLayer","_radixUiReactRovingFocus","orientation","currentTabStopId","onCurrentTabStopIdChange","onEntryFocus","Content","role","getOpenState","style","outline","isModifierKey","ctrlKey","altKey","metaKey","candidateNodes","reverse","candidates","PREVIOUSLY_FOCUSED_ELEMENT","candidate","focusFirst","onBlur","onPointerMove","whenMouse","pointerXHasChanged","newDir","MenuGroup","groupProps","Primitive","div","MenuLabel","labelProps","MenuItem","onSelect","itemProps","contentContext","isPointerDownRef","$e9e2cf92950df0b951e7bac95d18$var$MenuItemImpl","onClick","menuItem","itemSelectEvent","Event","bubbles","cancelable","once","dispatchEvent","defaultPrevented","onPointerDown","_props$onPointerDown","call","onPointerUp","_event$currentTarget","click","isTypingAhead","MenuSubTrigger","openTimerRef","clearOpenTimer","pointerGraceTimer","composeRefs","_props$onClick","onPointerLeave","_context$content","contentRect","getBoundingClientRect","_context$content2","dataset","rightSide","bleed","contentNearEdge","contentFarEdge","top","bottom","_context$content3","MenuItemImpl","textContent","setTextContent","_menuItem$textContent","trim","ItemSlot","Item","focusable","MenuCheckboxItem","checked","onCheckedChange","checkboxItemProps","$e9e2cf92950df0b951e7bac95d18$var$ItemIndicatorProvider","getCheckedState","RadioGroupProvider","useRadioGroupContext","onValueChange","MenuRadioGroup","handleValueChange","$e9e2cf92950df0b951e7bac95d18$var$RadioGroupProvider","MenuRadioItem","radioItemProps","_context$onValueChang","ItemIndicatorProvider","useItemIndicatorContext","MenuItemIndicator","itemIndicatorProps","indicatorContext","span","MenuSeparator","separatorProps","MenuArrow","arrowProps","Arrow","handler","pointerType","Sub","SubTrigger","Group","Label","CheckboxItem","RadioGroup","RadioItem","ItemIndicator","Separator"],"version":3,"file":"index.module.js.map"}