{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/focus-scope/src/FocusScope.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        if (!container.contains(event.relatedTarget as HTMLElement | null)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new Event(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(getTabbableCandidates(container), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new Event(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n"],"names":["dest","source","a","Object","keys","forEach","key","defineProperty","enumerable","get","__esModule","default","EVENT_OPTIONS","bubbles","cancelable","FocusScope","React","forwardRef","props","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","scopeProps","container","setContainer","useState","useCallbackRef","lastFocusedElementRef","useRef","composedRefs","useComposedRefs","node","focusScope","paused","pause","this","resume","current","useEffect","handleFocusIn","event","target","contains","focus","select","handleFocusOut","relatedTarget","document","addEventListener","removeEventListener","focusScopesStack","add","previouslyFocusedElement","activeElement","mountEvent","Event","dispatchEvent","defaultPrevented","candidates","candidate","focusFirst","getTabbableCandidates","setTimeout","unmountEvent","body","remove","handleKeyDown","useCallback","isTabKey","altKey","ctrlKey","metaKey","focusedElement","currentTarget","first","last","findVisible","reverse","getTabbableEdges","shiftKey","preventDefault","_react","createElement","Primitive","div","_babelRuntimeHelpersExtends","tabIndex","ref","onKeyDown","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","elements","element","isHidden","upTo","getComputedStyle","visibility","undefined","display","parentElement","preventScroll","HTMLInputElement","isSelectableInput","stack","activeFocusScope","arrayRemove","unshift","_stack$","createFocusScopesStack","array","item","updatedArray","index","indexOf","splice","Root"],"version":3,"file":"index.js.map"}